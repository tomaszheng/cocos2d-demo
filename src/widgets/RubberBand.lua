
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by tomas.
--- DateTime: 2021/6/1 17:54
---
local RubberBand = class("RubberBand", BaseNode)

local BOUNCE_SPEED = 25
local HOMING_DURATION = 0.1
local AMPLITUDE_MAX_ATTENUATION = 4
local AMPLITUDE_MIN_ATTENUATION = 1.5
local AMPLITUDE_ATTENUATION_SPEED = 0.3
local FINGER_WIDTH = 20
local TOUCH_RADIUS = 5
local MAX_BOUNCE_RAD = math.tan(10 * GeometryConstants.PI / 180)

function RubberBand:ctor(data)
    RubberBand.super.ctor(self, data)
    self:initData(data)
    self:initUI()
    self:initListeners()
    self:onUpdate(handler(self, self.update))
end

function RubberBand:initData(data)
    self:initEllipseData(data)
    self:initUIData(data)

    self.stretchPoint = cc.p(0, 0)
    self.isHoming = false
    self.bounceEnabled = false
    self.bounceSpeed = BOUNCE_SPEED
    self.maxAmplitude = -1
    self.minAmplitude = 1
    self.amplitudeAttenuation = AMPLITUDE_MAX_ATTENUATION
    self.graphics = nil
end

function RubberBand:initEllipseData(data)
    local startPos, endPos = data.startPos, data.endPos
    local distance = cc.pGetDistance(startPos, endPos)
    self.startPoint = cc.p(0, 0)
    self.endPoint = cc.p(distance, 0)
    self.centerPoint = cc.p(distance / 2, 0)
    self.a = distance / 2
    self.currB = 0
    self.startRad = -GeometryConstants.PI / 2
    self.endRad = GeometryConstants.PI / 2
end

function RubberBand:initUIData(data)
    local startPos, endPos = data.startPos, data.endPos
    if startPos.x > endPos.x then
        startPos, endPos = endPos, startPos
    end
    self.position = cc.pMul(cc.pAdd(endPos, startPos), 0.5)
    local normal = cc.pNormalize(cc.pSub(endPos, startPos))
    local xAxios = cc.p(1, 0)
    local rad = math.acos(cc.pDot(normal, xAxios))
    self.rotation = rad * 180 / GeometryConstants.PI
    if cc.pCross(normal, xAxios) < 0 then
        self.rotation = -self.rotation
    end
end

function RubberBand:initUI()
    local subPoint = cc.pSub(self.endPoint, self.startPoint)
    local absX = math.abs(subPoint.x)
    local absY = math.abs(subPoint.y)

    self.graphics = GraphicsNode.new():addTo(self)
    self.graphics:drawEllipse(self.centerPoint, self.a, self.currB, self.startRad, self.endRad)

    self:setContentSize(cc.size(absX, absY))
    self:move(self.position)
    self:setRotation(self.rotation)
end

function RubberBand:initListeners()
    self:addTouchEvent(handler(self, self.onTouchBegan),
            handler(self, self.onTouchMoved),
            handler(self, self.onTouchEnded))
end

function RubberBand:onTouchBegan(touch)
    local position = self:convertToNodeSpaceAR(touch:getLocation())
    local distance = GeometryUtils.pointLineDistance(position, self.startPoint, self.endPoint)
    return distance < TOUCH_RADIUS
end

function RubberBand:onTouchMoved(touch)
    local position = self:convertToNodeSpace(touch:getLocation())
    if self:isValidTouchPosition(position) then
        self.stretchPoint = position
        self:stretch(position, true)
    end
end

function RubberBand:isValidTouchPosition(position)
    local distance1 = cc.pGetDistance(self.startPoint, position)
    local distance2 = cc.pGetDistance(self.endPoint, position)
    return distance1 > FINGER_WIDTH and distance2 > FINGER_WIDTH
end

function RubberBand:onTouchEnded()
    self:bounce()
end

function RubberBand:stretch(point, isFromTouchEnded)
    local tangency1 = self:getTangencyOfStartPoint(point)
    local tangency2 = self:getTangencyOfEndPoint(point)

    local xAxios = cc.p(1, 0)
    local normal1 = cc.pNormalize(cc.pSub(tangency1, point))
    local normal2 = cc.pNormalize(cc.pSub(tangency2, point))
    local startRad = math.acos(cc.pDot(normal1, xAxios))
    local endRad = math.acos(cc.pDot(normal2, xAxios))

    if cc.pCross(normal1, xAxios) > 0 then
        startRad = 2 * GeometryConstants.PI - startRad
    end
    if cc.pCross(normal2, xAxios) > 0 then
        endRad = 2 * GeometryConstants.PI - endRad
    end

    local totalRad = endRad - startRad
    if cc.pCross(cc.pSub(tangency1, self.startPoint), cc.pSub(tangency2, self.startPoint)) < 0 then
        if endRad > startRad then
            totalRad = totalRad - 2 * GeometryConstants.PI
        end
    else
        totalRad = (2 * GeometryConstants.PI + totalRad) % (2 * GeometryConstants.PI)
    end

    self.graphics:clear()
    self.graphics:drawArc(point, FINGER_WIDTH, startRad, totalRad)
    self.graphics:drawSegment(self.startPoint, tangency1)
    self.graphics:drawSegment(self.endPoint, tangency2)
end

function RubberBand:getTangencyOfStartPoint(centerPoint)
    local point1, point2 = GeometryUtils.pointOfTangency(centerPoint, FINGER_WIDTH, self.startPoint)
    local distance1 = cc.pGetDistance(point1, self.endPoint)
    local distance2 = cc.pGetDistance(point2, self.endPoint)
    return distance1 > distance2 and point1 or point2
end

function RubberBand:getTangencyOfEndPoint(centerPoint)
    local point1, point2 = GeometryUtils.pointOfTangency(centerPoint, FINGER_WIDTH, self.endPoint)
    local distance1 = cc.pGetDistance(point1, self.startPoint)
    local distance2 = cc.pGetDistance(point2, self.startPoint)
    return distance1 > distance2 and point1 or point2
end

function RubberBand:bounce()
    self.bounceEnabled = false
    self.isHoming = true
    self.currB = self.centerPoint.y - self.stretchPoint.y
    self.maxAmplitude = math.min(self.a * MAX_BOUNCE_RAD, math.abs(self.currB))
    self.minAmplitude = -self.maxAmplitude
    self.bounceSpeed = BOUNCE_SPEED
    self.amplitudeAttenuation = AMPLITUDE_MAX_ATTENUATION
    self:homing()
end

function RubberBand:homing()
    local node = cc.Node:create():addTo(self)
    node:move(self.stretchPoint)
    node:runAction(cc.Sequence:create(
            cc.EaseIn:create(cc.MoveTo:create(HOMING_DURATION, self.centerPoint), 0.5),
            cc.CallFunc:create(function()
                self:onHomingCompleted()
            end),
            cc.RemoveSelf:create()
    ))
    node:repeatAction(function()
        self:stretch(cc.p(node:getPosition()))
    end, 0.01)
end

function RubberBand:onHomingCompleted()
    self.bounceEnabled = true
    self.isHoming = false
end

function RubberBand:update()
    if self.bounceEnabled and not self.isHoming then
        self:doBounce()
    end
end

function RubberBand:doBounce()
    self.maxAmplitude = self.maxAmplitude - self.amplitudeAttenuation
    self.minAmplitude = self.minAmplitude + self.amplitudeAttenuation
    self.amplitudeAttenuation = math.max(self.amplitudeAttenuation - AMPLITUDE_ATTENUATION_SPEED, AMPLITUDE_MIN_ATTENUATION)
    self.currB = self.currB + self.bounceSpeed

    if self.minAmplitude > self.maxAmplitude then
        self.minAmplitude, self.maxAmplitude = 0, 0
        self.currB = 0
        self.bounceEnabled = false
    end

    self:reviseB()
    self:adjustRadRange()
    self:redraw()
end

function RubberBand:reviseB()
    if self.currB <= self.minAmplitude then
        self.currB = self.minAmplitude
        self.bounceSpeed = -self.bounceSpeed
    elseif self.currB >= self.maxAmplitude then
        self.currB = self.maxAmplitude
        self.bounceSpeed = -self.bounceSpeed
    end
end

function RubberBand:adjustRadRange()
    if self.currB > 0 then
        self.startRad, self.endRad = -GeometryConstants.PI / 2, GeometryConstants.PI / 2
    else
        self.startRad, self.endRad = GeometryConstants.PI / 2, GeometryConstants.PI * 3 / 2
    end
end

function RubberBand:redraw()
    self.graphics:clear()
    self.graphics:drawEllipse(self.centerPoint, self.a, math.abs(self.currB), self.startRad, self.endRad)
end

return RubberBand
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by tomas.
--- DateTime: 2021/12/13 18:20
--- Content: 触摸组件
---
local Touchable = class("Touchable", BaseComponent)

Touchable.ON_BEGAN = "on-began"
Touchable.ON_MOVED = "on-moved"
Touchable.ON_ENDED = "on-ended"
Touchable.ON_CANCELED = "on-canceled"
Touchable.ON_LONG_TOUCH = "on-long-touch"
Touchable.ON_DESTROY = "on-destroy"

function Touchable:ctor(node, data)
    cc.load("event").new():bind(self)
    Touchable.super.ctor(self, node, data)
    self:initData(data)
    self:initListener()
end

function Touchable:initData(data)
    data = data or {}
    -- 响应的区域
    self._shape = data.shape or {}
    -- 是否启用长按
    self._isLongTouchEnabled = data.isLongTouchEnabled or false
    -- 触发长按的时间阈值
    self._longTouchThreshold = data.longTouchThreshold or 0.5
    -- touch的各个阶段
    self._onBeganFunc, self._onMovedFunc = data.onBegan, data.onMoved
    self._onEndedFunc, self._onCanceledFunc = data.onEnded, data.onCanceled
    self._onLongTouchFunc = data.onLongTouch
    -- 响应限制方法
    self._onLimitFunc = data.onLimit
    -- 是否可用
    self._isEnabled = data.isEnabled == nil and true or data.isEnabled

    -- 本次touch是否可用
    self._isCurrTouchEnabled = true

    self._touchListenerId = -1
    self._longTouchTimer = nil
    self._touchBeganPosition = cc.p(0, 0)
    self._touchCurrPosition = cc.p(0, 0)
end

function Touchable:initListener()
    self._touchListenerId = self.node:addTouchListener({
        onBegan = handler(self, self.onTouchBegan),
        onMoved = handler(self, self.onTouchMoved),
        onEnded = handler(self, self.onTouchEnded),
        onCanceled = handler(self, self.onTouchCanceled),
    })
end

function Touchable:onTouchBegan(touch)
    local position = touch:getLocation()

    if not self._isEnabled then return false end
    if not self._isCurrTouchEnabled then return false end
    if self._onLimitFunc and not doCallback(self._onLimitFunc, position) then
        return false
    end

    local isHit = self:isHit(position)
    self._touchBeganPosition = position
    self._touchCurrPosition = position
    self._isCurrTouchEnabled = true
    if isHit then
        self:dispatchEvent({name = Touchable.ON_BEGAN, sender = self, position = position})
        doCallback(self._onBeganFunc, {sender = self, position = position})
        self:startLongTouchTimer()
    end
    return isHit
end

function Touchable:onTouchMoved(touch)
    if not self._isCurrTouchEnabled then return false end

    local position = touch:getLocation()
    self._touchCurrPosition = position
    self:dispatchEvent({name = Touchable.ON_MOVED, sender = self, position = position})
    doCallback(self._onMovedFunc, {sender = self, position = position})
    return true
end

function Touchable:onTouchEnded(touch)
    if not self._isCurrTouchEnabled then return false end

    self:stopLongTouchTimer()

    local position = touch:getLocation()
    local isHit = self:isHit(position)
    self._touchCurrPosition = position
    self:dispatchEvent({name = Touchable.ON_ENDED, sender = self, position = position, isHit = isHit})
    doCallback(self._onEndedFunc, {sender = self, position = position, isHit = isHit})
    return true
end

function Touchable:onTouchCanceled()
    if not self._isCurrTouchEnabled then return false end

    self:stopLongTouchTimer()

    self:dispatchEvent({name = Touchable.ON_CANCELED, sender = self})
    doCallback(self._onCanceledFunc, {sender = self})
    return true
end

function Touchable:startLongTouchTimer()
    if not self._isLongTouchEnabled then return end

    self._longTouchTimer = self.node:delayAction(function()
        self:onLongTouch()
    end, self._longTouchThreshold)
end

function Touchable:stopLongTouchTimer()
    if self._longTouchTimer and isObjectExist(self._longTouchTimer) then
        self.node:stopAction(self._longTouchTimer)
        self._longTouchTimer = nil
    end
end

function Touchable:onLongTouch()
    local position = self._touchCurrPosition
    local isHit = self:isHit(position)
    self:dispatchEvent({name = Touchable.ON_LONG_TOUCH, sender = self, isHit = isHit, position = position})
    doCallback(self._onLongTouchFunc, {sender = self, isHit = isHit, position = position})
    return true
end

function Touchable:isHit(location)
    if not self.node:isAncestorsVisible() then return false end

    local position = self.node:convertToNodeSpace(location)
    if next(self._shape) then
        return IntersectionUtils.pInPolygon(position, self._shape)
    elseif type(self.node.isHit) == "function" then
        return self.node:isHit(position)
    else
        position = self.node:getParent():convertToNodeSpace(location)
        return cc.rectContainsPoint(self.node:getBoundingBox(), position)
    end
end

function Touchable:setOnLongTouch(func)
    if func and type(func) == "function" then
        self._onLongTouchFunc = func
    end
end

function Touchable:setLongTouchEnabled(enabled)
    self._isLongTouchEnabled = enabled
end

function Touchable:setLongTouchThreshold(threshold)
    if type(threshold) == "number" then
        self._longTouchThreshold = threshold
    end
end

function Touchable:setOnBegan(func)
    if func and type(func) == "function" then
        self._onBeganFunc = func
    end
end

function Touchable:setOnMoved(func)
    if func and type(func) == "function" then
        self._onMovedFunc = func
    end
end

function Touchable:setOnEnded(func)
    if func and type(func) == "function" then
        self._onEndedFunc = func
    end
end

function Touchable:setOnCanceled(func)
    if func and type(func) == "function" then
        self._onCanceledFunc = func
    end
end

function Touchable:setEnabled(isEnabled)
    self._isEnabled = isEnabled
end

function Touchable:setCurrTouchEnabled(isEnabled)
    self._isCurrTouchEnabled = isEnabled
end

function Touchable:onDestroy()
    self.node:removeTouchListener(self._touchListenerId)
    self:stopLongTouchTimer()
    self:dispatchEvent({name = Touchable.ON_DESTROY})
end

return Touchable
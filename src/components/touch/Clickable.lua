---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by tomas.
--- DateTime: 2021/12/14 10:30
--- Content: 点击组件
---
local Touchable = require("src.components.touch.Touchable")
local Interactive = require("src.components.touch.Interactive")
local TouchConstants = require("src.components.touch.TouchConstants")
local Clickable = class("Clickable", Touchable)

function Clickable:ctor(node, data)
    Clickable.super.ctor(self, node, data)
end

function Clickable:initData(data)
    Clickable.super.initData(self, data)
    data = data or {}
    -- 响应类型
    self._type = data.type or TouchConstants.TYPES.CLICK
    -- 按下有位移，是否可以响应
    self._isMoveLimit = data.isMoveLimit or false
    self._moveThreshold = data.moveThreshold or 5
    -- 两次按下是否有时间间隔限制
    self._isIntervalLimit = data.isIntervalLimit or false
    self._intervalThreshold = data.intervalThreshold or 0.5
    -- 长按
    self._isLongTouchEnabled = self._type == TouchConstants.TYPES.LONG_TOUCH
    -- 点击响应回调
    self._onClickFunc = data.onClick

    self._interactive = self.node:addLuaComponent(Interactive, data)

    -- 当前此touch是否是有效点击
    self._isCurrTouchValid = false
    self._prevTriggerTime = 0
end

function Clickable:onTouchBegan(touch)
    if not Clickable.super.onTouchBegan(self, touch) then return false end

    self._isCurrTouchValid = false

    self._interactive:press(touch:getLocation())

    return true
end

function Clickable:onLongTouch()
    self._interactive:loosen()

    if not self._isCurrTouchEnabled then return false end

    if self:isHit(self._touchCurrPosition) and not self:isClickLimiting() then
        self:trigger(Clickable.ON_LONG_TOUCH, self._onLongTouchFunc, self._touchCurrPosition)
    end
    return true
end

-- 触发了点击/长按/双击
function Clickable:trigger(name, func, position)
    self._isCurrTouchValid = true
    self._prevTriggerTime = os.clock()
    self:dispatchEvent({name = name, sender = self, position = position})
    doCallback(func, {sender = self, position = position})
end

function Clickable:onTouchEnded(touch)
    if self._type == TouchConstants.TYPES.CLICK then
        self._interactive:loosen()
    end
    self:stopLongTouchTimer()
    if not self._isCurrTouchEnabled then return false end

    local position = touch:getLocation()
    self._touchCurrPosition = position
    if self._type == TouchConstants.TYPES.CLICK then
        if self:isHit(position) and not self:isClickLimiting() then
            self:trigger(TouchConstants.ON_CLICK, self._onClickFunc, position)
        end
    end

    self:dispatchEvent({name = Touchable.ON_ENDED, sender = self, position = position, isValid = self._isCurrTouchValid})
    doCallback(self._onEndedFunc, {sender = self, position = position, isValid = self._isCurrTouchValid})
    return true
end

function Clickable:onTouchCanceled()
    self._interactive:loosen()

    return Clickable.super.onTouchCanceled(self)
end

function Clickable:isClickLimiting()
    if self._isIntervalLimit then
        if os.clock() - self._prevTriggerTime < self._intervalThreshold then
            return true
        end
    end
    if self._isMoveLimit then
        local distance = cc.pGetDistance(self._touchBeganPosition, self._touchCurrPosition)
        if distance > self._moveThreshold then
            return true
        end
    end
    return false
end

function Clickable:setOnClick(func)
    if func and type(func) == "function" then
        self._onClickFunc = func
    end
end

function Clickable:setInteractionFunc(func)
    self._interactive:setInteractionFunc(func)
end

function Clickable:updateOriginalData()
    self._interactive:updateOriginalData()
end

return Clickable
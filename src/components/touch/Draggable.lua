---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by tomas.
--- DateTime: 2021/12/15 15:40
--- 拖拽组件
---
local Touchable = require("src.components.touch.Touchable")
local Dragging = require("src.components.touch.Dragging")
local Interactive = require("src.components.touch.Interactive")
local Draggable = class("Draggable", Touchable)

local INTERACTIVE_ID = "DRAGGABLE"

function Draggable:ctor(node, data)
    Draggable.super.ctor(self, node, data)
end

function Draggable:initData(data)
    Draggable.super.initData(self, data)
    data = data or {}
    -- 拖拽移动时的响应限制函数
    self._onDragLimitFunc = data.onDragLimit
    -- 拖拽是否有位移限制
    self._isMoveLimitEnabled = data.moveLimitEnabled or false
    self._moveThreshold = data.moveThreshold or 5

    self._dragging = self.node:addLuaComponent(Dragging, data)

    self._interactive = self.node:addLuaComponent(Interactive, data)
    self._interactive:setId(INTERACTIVE_ID)

    self._isDragEnabled = true
    self._isCurrMoveTooShort = true
end

function Draggable:onTouchBegan(touch)
    if not self._isDragEnabled or self._dragging:isRebounding() then
        return false
    end

    if not Draggable.super.onTouchBegan(self, touch) then return false end

    self._isCurrMoveTooShort = true
    self._dragging:begin(self._touchCurrPosition)

    return true
end

function Draggable:onTouchMoved(touch)
    if not Draggable.super.onTouchMoved(self, touch) then return false end

    if self:isDragLimiting() then return false end

    if not self._interactive:isInteractiveStarted() then
        self._interactive:press(self._touchCurrPosition)
    end
    self._dragging:drag(self._touchCurrPosition)

    return true
end

function Draggable:onLongTouch()
    if not self._isCurrTouchEnabled then return false end

    if not self._interactive:isInteractiveStarted() then
        self._interactive:press(self._touchCurrPosition)
    end
    if not self:isLongTouchLimiting() then
        self._dragging:drag(self._touchCurrPosition)
    end

    return true
end

function Draggable:onTouchEnded(touch)
    if not Draggable.super.onTouchEnded(self, touch) then return false end
    self._dragging:ended()
    self._interactive:loosen()
    return true
end

function Draggable:onTouchCanceled()
    if not Draggable.super.onTouchCanceled(self) then return false end
    self._dragging:ended()
    self._interactive:loosen()
    return true
end

function Draggable:isDragLimiting()
    if self._isMoveLimitEnabled then
        if not self._isCurrMoveTooShort then
            return false
        else
            local distance = cc.pGetDistance(self._touchBeganPosition, self._touchCurrPosition)
            if distance > self._moveThreshold then
                self._isCurrMoveTooShort = false
                return false
            end
        end
    end
    if self._onDragLimitFunc then
        return doCallback(self._onDragLimitFunc, self._touchCurrPosition)
    end
    return false
end

function Draggable:isLongTouchLimiting()
    if self._onDragLimitFunc then
        return doCallback(self._onDragLimitFunc, self._touchCurrPosition)
    end
    return false
end

function Draggable:setDragEnabled(enabled)
    self._isDragEnabled = enabled
end

function Draggable:setRebounding(rebounding)
    self._dragging:setRebounding(rebounding)
end

function Draggable:isDragCompleted()
    return self._dragging:isDragCompleted()
end

function Draggable:onDestroy()
    Draggable.super.onDestroy(self)
    self.node:removeLuaComponentById(INTERACTIVE_ID)
end

return Draggable
